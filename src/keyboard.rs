use windows::Win32::UI::Input::KeyboardAndMouse::{
    GetKeyState, MAPVK_VSC_TO_VK, MapVirtualKeyA, VK_CAPITAL,
};

#[cfg(feature = "winit")]
use winit::{
    event::KeyEvent,
    keyboard::{NativeKeyCode, PhysicalKey},
    platform::scancode::PhysicalKeyExtScancode,
};

/// Represents modifier keys
///
/// This is mainly used for keyboard events
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub enum KeyboardModifiers {
    None,
    Shift,
    Ctrl,
    Alt,
    Win,
}

/// Represents the type of key event
///
/// This is mainly used for keyboard events
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyboardEventType {
    KeyDown,
    KeyUp,
    Char,
}

/// Represents a key event
///
/// This is mainly used for keyboard events
#[derive(Debug, Copy, Clone)]
pub struct KeyboardEvent {
    /// The type of keyboard event.
    pub ty: KeyboardEventType,
    /// The modifiers of the keyboard event.
    pub modifiers: KeyboardModifiers,
    /// The Windows key code for the key event.
    pub windows_key_code: u32,
    /// The actual key code genenerated by the platform.
    pub native_key_code: u32,
    /// Indicates whether the event is considered a "system key" event.
    ///
    /// see http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details
    pub is_system_key: u32,
    /// The character generated by the keystroke.
    pub character: u16,
    /// Same as |character| but unmodified by any concurrently-held modifiers
    /// (except shift).
    pub unmodified_character: u16,
    /// True if the focus is currently on an editable field on the page.
    pub focus_on_editable_field: bool,
}

#[cfg(target_os = "windows")]
pub fn get_capslock_state() -> bool {
    (unsafe { GetKeyState(VK_CAPITAL.0 as i32) } & 0x0001) != 0
}

#[cfg(feature = "winit")]
pub struct WinitKeyboardAdapter;

#[cfg(feature = "winit")]
impl WinitKeyboardAdapter {
    pub fn get_key_event(input: &KeyEvent) -> Vec<KeyboardEvent> {
        let mut events: Vec<KeyboardEvent> = Vec::with_capacity(2);

        let mut event: KeyboardEvent = unsafe { std::mem::zeroed() };

        {
            match input.physical_key {
                PhysicalKey::Code(code) => {
                    if let Some(scancode) = code.to_scancode() {
                        event.native_key_code = scancode as u32;
                    }
                }
                PhysicalKey::Unidentified(code) => {
                    event.native_key_code = match code {
                        NativeKeyCode::Windows(code) | NativeKeyCode::MacOS(code) => code as u32,
                        NativeKeyCode::Xkb(code) => code,
                        _ => unimplemented!("not supports android platfrom!"),
                    };
                }
            }

            if let Some(text) = &input.text {
                if let Some(character) = text.chars().next() {
                    event.unmodified_character = character as u16;
                    event.character = character as u16;
                }
            }

            #[cfg(target_os = "windows")]
            {
                event.windows_key_code =
                    unsafe { MapVirtualKeyA(event.native_key_code, MAPVK_VSC_TO_VK) };

                if event.native_key_code >= 0x10
                    && event.native_key_code <= 0x37
                    && event.native_key_code != 28
                {
                    event.windows_key_code += 32;
                }
            }

            event.focus_on_editable_field = true;
            event.modifiers = KeyboardModifiers::None;
            event.ty = if input.state.is_pressed() {
                KeyboardEventType::KeyDown
            } else {
                KeyboardEventType::KeyUp
            };

            events.push(event.clone());
        }

        if input.state.is_pressed() {
            event.ty = KeyboardEventType::Char;

            events.push(event);
        }

        return events;
    }
}
