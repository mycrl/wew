use bitflags::bitflags;

#[cfg(target_os = "windows")]
use windows::Win32::UI::Input::KeyboardAndMouse::{
    GetKeyState, MAPVK_VSC_TO_VK_EX, MapVirtualKeyA, VK_CAPITAL,
};

#[cfg(feature = "winit")]
use crate::{WindowlessRenderWebView, webview::WebView};

/// Represents a position
///
/// This is mainly used for mouse and touch events
#[derive(Debug, Clone, Copy)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

/// Represents a mouse button
///
/// This is mainly used for mouse events
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub enum MouseButton {
    Left,
    Middle,
    Right,
}

/// Represents a rectangular area
#[derive(Debug, Clone, Copy)]
pub struct Rect {
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
}

/// Represents a mouse event
///
/// This is mainly used for mouse events
#[derive(Debug, Clone)]
pub enum MouseEvent {
    /// Click a mouse button
    ///
    /// Position is optional, if position is None, it means the mouse is at the
    /// last position
    Click(MouseButton, bool, Option<Position>),
    /// Move the mouse
    Move(Position),
    /// Scroll the mouse wheel
    Wheel(Position),
}

/// Represents an IME event
///
/// This is mainly used for IME events
#[derive(Debug)]
pub enum IMEAction<'a> {
    Composition(&'a str),
    Pre(&'a str, i32, i32),
}

bitflags! {
    /// Represents modifier keys
    ///
    /// This is mainly used for keyboard events
    #[derive(PartialEq, Eq, Debug, Clone, Copy)]
    pub struct KeyboardModifiers: u8 {
        const None = 0;
        const Shift = 1;
        const Ctrl = 2;
        const Alt = 4;
        const Win = 8;
        const Command = 16;
        const CapsLock = 32;
    }
}

impl Default for KeyboardModifiers {
    fn default() -> Self {
        Self::None
    }
}

/// Represents the type of key event
///
/// This is mainly used for keyboard events
#[derive(Default, Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyboardEventType {
    #[default]
    KeyDown,
    KeyUp,
    Char,
}

/// Represents a key event
///
/// This is mainly used for keyboard events
#[derive(Default, Debug, Copy, Clone)]
pub struct KeyboardEvent {
    /// The type of keyboard event.
    pub ty: KeyboardEventType,
    /// The modifiers of the keyboard event.
    pub modifiers: KeyboardModifiers,
    /// The Windows key code for the key event.
    pub windows_key_code: u32,
    /// The actual key code genenerated by the platform.
    pub native_key_code: u32,
    /// Indicates whether the event is considered a "system key" event.
    ///
    /// see [WM_SYSKEYDOWN message](https://learn.microsoft.com/zh-cn/windows/win32/inputdev/wm-syskeydown) for details
    pub is_system_key: u32,
    /// The character generated by the keystroke.
    pub character: u16,
    /// Same as |character| but unmodified by any concurrently-held modifiers
    /// (except shift).
    pub unmodified_character: u16,
    /// True if the focus is currently on an editable field on the page.
    pub focus_on_editable_field: bool,
}

/// Adapter that automatically handles various external system window events
///
/// Used to adapt window events from various external systems, and the adapter
/// automatically converts and drives the WebView.
#[allow(unused)]
#[derive(Default)]
pub struct EventAdapter {
    modifiers: KeyboardModifiers,
}

#[cfg(feature = "winit")]
impl EventAdapter {
    const SCANCODE_LSHIFT: u32 = 42;
    const SCANCODE_RSHIFT: u32 = 54;
    const SCANCODE_LCTRL: u32 = 29;
    const SCANCODE_ENTER: u32 = 28;
    const SCANCODE_SPACE: u32 = 57;

    /// Get the state of the capslock key
    ///
    /// This method directly calls the operating system API to get the current
    /// system capslock state.
    #[cfg(target_os = "windows")]
    fn get_capslock_state() -> bool {
        return (unsafe { GetKeyState(VK_CAPITAL.0 as i32) } & 0x0001) != 0;
    }

    /// Handling window events for `winit`
    ///
    /// ## Example
    ///
    /// ```ignore
    /// struct App {
    ///     webview: WebView<MessagePumpLoop, WindowlessRenderWebView>,
    ///     event_adapter: EventAdapter,
    /// }
    ///
    /// impl ApplicationHandler for App {
    ///     fn window_event(
    ///         &mut self,
    ///         event_loop: &ActiveEventLoop,
    ///         _window_id: WindowId,
    ///         event: WindowEvent,
    ///     ) {
    ///         self.event_adapter
    ///             .on_winit_window_event(&mut self.webview, &event);
    ///     }
    /// }
    /// ```
    pub fn on_winit_window_event<R>(
        &mut self,
        webview: &WebView<R, WindowlessRenderWebView>,
        event: &winit::event::WindowEvent,
    ) {
        use winit::{
            event::{Ime, MouseButton as WtMouseButton, MouseScrollDelta, WindowEvent},
            keyboard::{Key, KeyCode, ModifiersState, NativeKeyCode, PhysicalKey},
            platform::scancode::PhysicalKeyExtScancode,
        };

        match event {
            WindowEvent::Ime(ime) => match ime {
                Ime::Commit(composition) => {
                    webview.ime(&IMEAction::Composition(composition));
                }
                Ime::Preedit(preedit, Some((cursor_pos, selection_start))) => {
                    webview.ime(&IMEAction::Pre(
                        preedit,
                        *cursor_pos as i32,
                        *selection_start as i32,
                    ));
                }
                // Because key events are triggered before IME events, an extra character is output.
                // If IME events are enabled, the previously entered character should be deleted.
                Ime::Enabled => {
                    let mut event = KeyboardEvent {
                        ty: KeyboardEventType::KeyDown,
                        modifiers: KeyboardModifiers::None,
                        windows_key_code: 8,
                        native_key_code: 14,
                        is_system_key: 0,
                        character: 8,
                        unmodified_character: 8,
                        focus_on_editable_field: false,
                    };

                    webview.keyboard(&event);

                    event.ty = KeyboardEventType::KeyUp;

                    webview.keyboard(&event);
                }
                _ => (),
            },
            WindowEvent::ModifiersChanged(modifiers) => {
                self.modifiers = KeyboardModifiers::None;

                let state = modifiers.state();
                for it in ModifiersState::all() {
                    if state.contains(it) {
                        self.modifiers |= match it {
                            ModifiersState::SHIFT => KeyboardModifiers::Shift,
                            ModifiersState::CONTROL => KeyboardModifiers::Ctrl,
                            ModifiersState::ALT => KeyboardModifiers::Alt,
                            ModifiersState::SUPER => {
                                if cfg!(target_os = "macos") {
                                    KeyboardModifiers::Command
                                } else {
                                    KeyboardModifiers::Win
                                }
                            }
                            _ => KeyboardModifiers::None,
                        };
                    }
                }

                #[cfg(target_os = "windows")]
                if Self::get_capslock_state() {
                    self.modifiers |= KeyboardModifiers::CapsLock;
                }
            }
            WindowEvent::KeyboardInput { event: input, .. } => {
                {
                    if !input.state.is_pressed() {
                        if let PhysicalKey::Code(KeyCode::CapsLock) = input.physical_key {
                            self.modifiers |= KeyboardModifiers::CapsLock;
                        }
                    }
                }

                let mut event = KeyboardEvent::default();
                event.modifiers = self.modifiers;
                event.ty = if input.state.is_pressed() {
                    KeyboardEventType::KeyDown
                } else {
                    KeyboardEventType::KeyUp
                };

                event.native_key_code = match input.physical_key {
                    PhysicalKey::Code(code) => {
                        if let Some(scancode) = code.to_scancode() {
                            scancode as u32
                        } else {
                            0
                        }
                    }
                    PhysicalKey::Unidentified(code) => match code {
                        NativeKeyCode::Windows(code) | NativeKeyCode::MacOS(code) => code as u32,
                        NativeKeyCode::Xkb(code) => code,
                        _ => unimplemented!("not supports android platfrom!"),
                    },
                };

                if let Some(text) = input.text.as_ref().or_else(|| {
                    if let Key::Character(text) = &input.logical_key {
                        Some(text)
                    } else {
                        None
                    }
                }) {
                    if let Some(character) = text.chars().next() {
                        event.unmodified_character = character as u16;
                        event.character = character as u16;
                    }
                }

                #[cfg(target_os = "windows")]
                {
                    event.windows_key_code =
                        unsafe { MapVirtualKeyA(event.native_key_code, MAPVK_VSC_TO_VK_EX) };
                }

                webview.keyboard(&event);

                // When the key is pressed, an additional `char` event must be sent.
                if input.state.is_pressed() {
                    event.ty = KeyboardEventType::Char;

                    if cfg!(not(target_os = "windows")) {
                        webview.keyboard(&event);
                    } else {
                        if event.native_key_code != Self::SCANCODE_LSHIFT
                            && event.native_key_code != Self::SCANCODE_RSHIFT
                            && event.native_key_code != Self::SCANCODE_LCTRL
                        {
                            let is_ascii =
                                event.native_key_code >= 0x10 && event.native_key_code <= 0x37;

                            if !self.modifiers.contains(KeyboardModifiers::CapsLock)
                                && !self.modifiers.contains(KeyboardModifiers::Shift)
                                && is_ascii
                                && event.native_key_code != Self::SCANCODE_ENTER
                            {
                                event.windows_key_code += 32;
                            }

                            let mut is_number_symbol = false;
                            if let Some(mapping) = event.native_key_code.symbol_mapping() {
                                is_number_symbol = true;

                                event.windows_key_code =
                                    if self.modifiers.contains(KeyboardModifiers::Shift) {
                                        mapping.upcase as u32
                                    } else {
                                        mapping.base as u32
                                    };
                            }

                            if is_number_symbol
                                || is_ascii
                                || event.native_key_code == Self::SCANCODE_SPACE
                            {
                                webview.keyboard(&event);
                            }
                        }
                    }
                }
            }
            WindowEvent::MouseInput { state, button, .. } => {
                webview.mouse(&MouseEvent::Click(
                    match button {
                        WtMouseButton::Left => MouseButton::Left,
                        WtMouseButton::Right => MouseButton::Right,
                        _ => MouseButton::Middle,
                    },
                    state.is_pressed(),
                    None,
                ));
            }
            WindowEvent::MouseWheel { delta, .. } => {
                let (x, y) = match delta {
                    MouseScrollDelta::PixelDelta(pos) => (pos.x as i32, pos.y as i32),
                    MouseScrollDelta::LineDelta(x, y) => ((x * 20.0) as i32, (y * 20.0) as i32),
                };

                webview.mouse(&MouseEvent::Wheel(Position { x, y }));
            }
            WindowEvent::CursorMoved { position, .. } => {
                webview.mouse(&MouseEvent::Move(Position {
                    x: position.x as i32,
                    y: position.y as i32,
                }));
            }
            WindowEvent::Focused(state) => {
                webview.focus(*state);

                // Since events cannot be captured when not in focus, the case
                // state must be reacquired when refocusing.
                #[cfg(target_os = "windows")]
                if *state && Self::get_capslock_state() {
                    self.modifiers |= KeyboardModifiers::CapsLock;
                }
            }
            WindowEvent::Resized(size) => {
                webview.resize(size.width, size.height);
            }
            _ => {}
        }
    }
}

#[cfg(feature = "winit")]
struct SymbolMapping {
    base: char,
    upcase: char,
}

#[cfg(feature = "winit")]
trait Win32ScanCodeCapsLockExt {
    fn symbol_mapping(&self) -> Option<&SymbolMapping>;
}

#[cfg(feature = "winit")]
static SCANCODE_SYMBOL_MAPPING: &[(u32, SymbolMapping)] = &[
    (
        2,
        SymbolMapping {
            base: '1',
            upcase: '!',
        },
    ),
    (
        3,
        SymbolMapping {
            base: '2',
            upcase: '@',
        },
    ),
    (
        4,
        SymbolMapping {
            base: '3',
            upcase: '#',
        },
    ),
    (
        5,
        SymbolMapping {
            base: '4',
            upcase: '$',
        },
    ),
    (
        6,
        SymbolMapping {
            base: '5',
            upcase: '%',
        },
    ),
    (
        7,
        SymbolMapping {
            base: '6',
            upcase: '^',
        },
    ),
    (
        8,
        SymbolMapping {
            base: '7',
            upcase: '&',
        },
    ),
    (
        9,
        SymbolMapping {
            base: '8',
            upcase: '*',
        },
    ),
    (
        10,
        SymbolMapping {
            base: '9',
            upcase: '(',
        },
    ),
    (
        11,
        SymbolMapping {
            base: '0',
            upcase: ')',
        },
    ),
    (
        12,
        SymbolMapping {
            base: '-',
            upcase: '_',
        },
    ),
    (
        13,
        SymbolMapping {
            base: '=',
            upcase: '+',
        },
    ),
    (
        26,
        SymbolMapping {
            base: '[',
            upcase: '(',
        },
    ),
    (
        27,
        SymbolMapping {
            base: ']',
            upcase: ')',
        },
    ),
    (
        39,
        SymbolMapping {
            base: ';',
            upcase: ':',
        },
    ),
    (
        40,
        SymbolMapping {
            base: '\'',
            upcase: '"',
        },
    ),
    (
        41,
        SymbolMapping {
            base: '`',
            upcase: '~',
        },
    ),
    (
        43,
        SymbolMapping {
            base: '\\',
            upcase: '|',
        },
    ),
    (
        51,
        SymbolMapping {
            base: ',',
            upcase: '<',
        },
    ),
    (
        52,
        SymbolMapping {
            base: '.',
            upcase: '>',
        },
    ),
    (
        53,
        SymbolMapping {
            base: '/',
            upcase: '?',
        },
    ),
];

#[cfg(feature = "winit")]
impl Win32ScanCodeCapsLockExt for u32 {
    fn symbol_mapping(&self) -> Option<&SymbolMapping> {
        SCANCODE_SYMBOL_MAPPING
            .iter()
            .find(|(code, _)| code == self)
            .map(|(_, mapping)| mapping)
    }
}
