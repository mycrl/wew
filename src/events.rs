use bitflags::bitflags;

#[cfg(target_os = "windows")]
use windows::Win32::UI::Input::KeyboardAndMouse::{
    GetKeyState, MAPVK_VSC_TO_VK, MapVirtualKeyA, VK_CAPITAL,
};

use crate::{WindowlessRenderWebView, webview::WebView};

/// Represents a position
///
/// This is mainly used for mouse and touch events
#[derive(Debug, Clone, Copy)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

/// Represents a mouse button
///
/// This is mainly used for mouse events
#[derive(PartialEq, Eq, Debug, Clone, Copy)]
pub enum MouseButton {
    Left,
    Middle,
    Right,
}

/// Represents a rectangular area
#[derive(Debug, Clone, Copy)]
pub struct Rect {
    pub x: u32,
    pub y: u32,
    pub width: u32,
    pub height: u32,
}

/// Represents a mouse event
///
/// This is mainly used for mouse events
#[derive(Debug, Clone)]
pub enum MouseAction {
    /// Click a mouse button
    ///
    /// Position is optional, if position is None, it means the mouse is at the
    /// current position
    Click(MouseButton, bool, Option<Position>),
    /// Move the mouse
    Move(Position),
    /// Scroll the mouse wheel
    Wheel(Position),
}

/// Represents an IME event
///
/// This is mainly used for IME events
#[derive(Debug)]
pub enum IMEAction<'a> {
    Composition(&'a str),
    Pre(&'a str, i32, i32),
}

bitflags! {
    /// Represents modifier keys
    ///
    /// This is mainly used for keyboard events
    #[derive(PartialEq, Eq, Debug, Clone, Copy)]
    pub struct KeyboardModifiers: u8 {
        const None = 0;
        const Shift = 1;
        const Ctrl = 2;
        const Alt = 4;
        const Win = 8;
        const Command = 16;
        const CapsLock = 32;
    }
}

impl Default for KeyboardModifiers {
    fn default() -> Self {
        Self::None
    }
}

/// Represents the type of key event
///
/// This is mainly used for keyboard events
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum KeyboardEventType {
    KeyDown,
    KeyUp,
    Char,
}

/// Represents a key event
///
/// This is mainly used for keyboard events
#[derive(Debug, Copy, Clone)]
pub struct KeyboardEvent {
    /// The type of keyboard event.
    pub ty: KeyboardEventType,
    /// The modifiers of the keyboard event.
    pub modifiers: KeyboardModifiers,
    /// The Windows key code for the key event.
    pub windows_key_code: u32,
    /// The actual key code genenerated by the platform.
    pub native_key_code: u32,
    /// Indicates whether the event is considered a "system key" event.
    ///
    /// see http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details
    pub is_system_key: u32,
    /// The character generated by the keystroke.
    pub character: u16,
    /// Same as |character| but unmodified by any concurrently-held modifiers
    /// (except shift).
    pub unmodified_character: u16,
    /// True if the focus is currently on an editable field on the page.
    pub focus_on_editable_field: bool,
}

#[allow(unused)]
#[derive(Default)]
pub struct EventAdapter {
    modifiers: KeyboardModifiers,
    allow_ime: bool,
}

impl EventAdapter {
    /// Get the state of the capslock key
    ///
    /// This is mainly used for keyboard events
    pub fn get_capslock_state() -> bool {
        #[allow(unused_mut)]
        let mut state = false;

        #[cfg(target_os = "windows")]
        {
            state = (unsafe { GetKeyState(VK_CAPITAL.0 as i32) } & 0x0001) != 0;
        }

        state
    }
}

impl EventAdapter {
    #[cfg(feature = "winit")]
    pub fn on_winit_window_event<R>(
        &mut self,
        webview: &WebView<R, WindowlessRenderWebView>,
        event: &winit::event::WindowEvent,
    ) {
        use winit::{
            event::{Ime, MouseButton as WtMouseButton, MouseScrollDelta, WindowEvent},
            keyboard::{Key, ModifiersState, NativeKeyCode, PhysicalKey},
            platform::scancode::PhysicalKeyExtScancode,
        };

        match event {
            WindowEvent::Ime(ime) => match ime {
                Ime::Commit(composition) => {
                    if self.allow_ime {
                        webview.ime(&IMEAction::Composition(composition));
                    }
                }
                Ime::Preedit(preedit, Some((cursor_pos, selection_start))) => {
                    if self.allow_ime {
                        webview.ime(&IMEAction::Pre(
                            preedit,
                            *cursor_pos as i32,
                            *selection_start as i32,
                        ));
                    }
                }
                Ime::Enabled => {
                    self.allow_ime = true;
                }
                Ime::Disabled => {
                    self.allow_ime = false;
                }
                _ => (),
            },
            WindowEvent::ModifiersChanged(modifiers) => {
                if self.allow_ime {
                    return;
                }

                self.modifiers = KeyboardModifiers::None;

                let state = modifiers.state();
                for it in ModifiersState::all() {
                    if state.contains(it) {
                        self.modifiers |= match it {
                            ModifiersState::SHIFT => KeyboardModifiers::Shift,
                            ModifiersState::CONTROL => KeyboardModifiers::Ctrl,
                            ModifiersState::ALT => KeyboardModifiers::Alt,
                            ModifiersState::SUPER => {
                                if cfg!(target_os = "macos") {
                                    KeyboardModifiers::Command
                                } else {
                                    KeyboardModifiers::Win
                                }
                            }
                            _ => KeyboardModifiers::None,
                        };
                    }
                }

                if Self::get_capslock_state() {
                    self.modifiers |= KeyboardModifiers::CapsLock;
                }
            }
            WindowEvent::KeyboardInput { event: input, .. } => {
                if self.allow_ime {
                    return;
                }

                let mut event: KeyboardEvent = unsafe { std::mem::zeroed() };

                match input.physical_key {
                    PhysicalKey::Code(code) => {
                        if let Some(scancode) = code.to_scancode() {
                            event.native_key_code = scancode as u32;
                        }
                    }
                    PhysicalKey::Unidentified(code) => {
                        event.native_key_code = match code {
                            NativeKeyCode::Windows(code) | NativeKeyCode::MacOS(code) => {
                                code as u32
                            }
                            NativeKeyCode::Xkb(code) => code,
                            _ => unimplemented!("not supports android platfrom!"),
                        };
                    }
                }

                if let Some(text) = input.text.as_ref().or_else(|| {
                    if let Key::Character(text) = &input.logical_key {
                        Some(text)
                    } else {
                        None
                    }
                }) {
                    if let Some(character) = text.chars().next() {
                        event.unmodified_character = character as u16;
                        event.character = character as u16;
                    }
                }

                #[cfg(target_os = "windows")]
                {
                    event.windows_key_code =
                        unsafe { MapVirtualKeyA(event.native_key_code, MAPVK_VSC_TO_VK) };
                }

                event.focus_on_editable_field = true;
                event.modifiers = self.modifiers;
                event.ty = if input.state.is_pressed() {
                    KeyboardEventType::KeyDown
                } else {
                    KeyboardEventType::KeyUp
                };

                webview.keyboard(&event);

                // When the key is pressed, an additional `char` event must be sent.
                if input.state.is_pressed() {
                    event.ty = KeyboardEventType::Char;

                    webview.keyboard(&event);
                }
            }
            WindowEvent::MouseInput { state, button, .. } => {
                webview.mouse(&MouseAction::Click(
                    match button {
                        WtMouseButton::Left => MouseButton::Left,
                        WtMouseButton::Right => MouseButton::Right,
                        _ => MouseButton::Middle,
                    },
                    state.is_pressed(),
                    None,
                ));
            }
            WindowEvent::MouseWheel { delta, .. } => {
                let (x, y) = match delta {
                    MouseScrollDelta::PixelDelta(pos) => (pos.x as i32, pos.y as i32),
                    MouseScrollDelta::LineDelta(x, y) => ((x * 20.0) as i32, (y * 20.0) as i32),
                };

                webview.mouse(&MouseAction::Wheel(Position { x, y }));
            }
            WindowEvent::CursorMoved { position, .. } => {
                webview.mouse(&MouseAction::Move(Position {
                    x: position.x as i32,
                    y: position.y as i32,
                }));
            }
            WindowEvent::Focused(state) => {
                webview.focus(*state);

                // Since events cannot be captured when not in focus, the case
                // state must be reacquired when refocusing.
                if *state && Self::get_capslock_state() {
                    self.modifiers |= KeyboardModifiers::CapsLock;
                }
            }
            _ => {}
        }
    }
}
